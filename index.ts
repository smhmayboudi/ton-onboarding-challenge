import { getHttpEndpoint } from "@orbs-network/ton-access";
import { Address, TonClient, toNano } from "ton";
import { BN } from "bn.js";
import { unixNow } from "./src/lib/utils";
import { MineMessageParams, Queries } from "./src/giver/NftGiver.data";
import qrcode from "qrcode-terminal";

async function main() {
  const walletAddress = "0QAH7vAwpQgUG3bkPvshNvCa9GiMG-lT2Kw4uQTkweDuflzh";
  const wallet = Address.parse(walletAddress);
  console.debug("wallet", wallet);

  const collectionAddress = "EQDk8N7xM5D669LC2YACrseBJtDyFqwtSPCNhRWXU7kjEptX";
  const collection = Address.parse(collectionAddress);
  console.debug("collection", collection);

  const endpoint = await getHttpEndpoint({
    network: "testnet",
  });
  console.debug("endpoint", endpoint);

  const client = new TonClient({ endpoint });
  console.debug("client", client);

  const miningData = await client.callGetMethod(collection, "get_mining_data");
  console.debug("miningData", miningData);

  // pow_complexity is the most important number for miners. It's a Proof-of-Work complexity for the values. You're successful if the final hash is less than complexity.
  // last_success is a unix timestamp date and time representation that keeps track of the last mining transaction on TON. Each time the last_success metric changes, it's necessary to run the miner again because the seed also changes during this process.
  // seed denotes a unique value generated by a smart contract to calculate the desired hash. To better understand this process and learn more about how the seed changes and why, have a look at the project files folder by using the ctx_seed keyword(Ctrl+F with keyword "ctx_seed").
  // target_delta, min_cpl and max_cpl won't be used in our tutorial. But you can always read more about how they are used in smart contracts to calculate proof-of-work complexity in the source files of the collection in your project.

  let [
    [, pow_complexity],
    [, last_success],
    [, seed],
    [, target_delta],
    [, min_cpl],
    [, max_cpl],
  ] = miningData.stack;
  console.debug("pow_complexity", pow_complexity);
  console.debug("last_success", last_success);
  console.debug("seed", seed);
  console.debug("target_delta", target_delta);
  console.debug("min_cpl", min_cpl);
  console.debug("max_cpl", max_cpl);

  const parseStackNum = (sn: any) => new BN(sn[1].substring(2), "hex");
  pow_complexity = parseStackNum(miningData.stack[0]);
  last_success = parseStackNum(miningData.stack[1]);
  seed = parseStackNum(miningData.stack[2]);
  target_delta = parseStackNum(miningData.stack[3]);
  min_cpl = parseStackNum(miningData.stack[4]);
  max_cpl = parseStackNum(miningData.stack[5]);

  console.debug("pow_complexity", pow_complexity);
  console.debug("last_success", last_success.toString());
  console.debug("seed", seed);
  console.debug("target_delta", target_delta.toString());
  console.debug("min_cpl", min_cpl.toString());
  console.debug("max_cpl", max_cpl.toString());

  const mineParams: MineMessageParams = {
    expire: unixNow() + 300, // 5 min is enough to make a transaction
    mintTo: wallet, // your wallet
    data1: new BN(0), // temp variable to increment in the miner
    seed, // unique seed from get_mining_data
  };
  console.debug("mineParams", mineParams);

  let msg = Queries.mine(mineParams); // transaction builder
  let progress = 0;
  while (new BN(msg.hash(), "be").gt(pow_complexity)) {
    progress += 1;
    // console.clear();
    console.log(
      `Mining started: please, wait for 30-60 seconds to mine your NFT!`
    );
    console.log(
      `\n‚õè Mined ${progress} hashes! Last: `,
      new BN(msg.hash(), "be").toString()
    );

    mineParams.expire = unixNow() + 300;
    mineParams.data1.iaddn(1);
    msg = Queries.mine(mineParams);
  }

  console.log(
    "\nüíé Mission completed: msg_hash less than pow_complexity found!\n"
  );
  console.log("msg_hash: ", new BN(msg.hash(), "be").toString());
  console.log("pow_complexity: ", pow_complexity.toString());
  console.log(
    "msg_hash < pow_complexity: ",
    new BN(msg.hash(), "be").lt(pow_complexity)
  );

  console.log(
    "\nüí£ WARNING! As soon as you find the hash, you should quickly send the transaction.",
    "If someone else sends a transaction before you, the seed changes, and you'll have to find the hash again!\n"
  );

  /** flags work only in user-friendly address form */
  const collectionAddr = collection.toFriendly({
    urlSafe: true,
    bounceable: true,
  });
  /** we must convert TON to nanoTON */
  const amountToSend = toNano("0.05").toString();
  /** BOC means Bag Of Cells here */
  const preparedBodyCell = msg.toBoc().toString("base64url");
  /** final method to build a payment URL */
  const tonDeepLink = (address: string, amount: string, body: string) => {
    return `ton://transfer/${address}?amount=${amount}&bin=${body}`;
  };
  const link = tonDeepLink(collectionAddr, amountToSend, preparedBodyCell);
  console.log("üöÄ Link to receive an NFT:", link);

  qrcode.generate(link, { small: true }, function (qrcode: any) {
    console.log("üöÄ Link to mine your NFT (use Tonkeeper in testnet mode):");
    console.log(qrcode);
    console.log(
      "* If QR is still too big, please run script from the terminal. (or make the font smaller)"
    );
  });
}

main();
